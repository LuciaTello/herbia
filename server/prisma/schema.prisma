// Prisma Schema: like your @Entity classes in JPA/Hibernate
// Each "model" becomes a table in PostgreSQL AND a TypeScript type

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Like @Entity User in JPA
// In Spring Security, this is often called "AppUser" to avoid conflicts
model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique                        // Like @Column(unique = true)
  passwordHash String   @map("password_hash")          // NEVER store plain passwords!
  createdAt    DateTime @default(now())

  // One-to-many: a user has many treks
  // Like @OneToMany(mappedBy = "user") List<Trek> treks;
  treks        Trek[]

  @@map("users")
}

// A trek represents a search (origin â†’ destination) with its suggested plants
// Like @Entity Trek in JPA
model Trek {
  id          Int              @id @default(autoincrement())
  origin      String
  destination String
  description String           @default("")  // General vegetation overview for this route/month
  month       Int              // 1-12, for seasonal plant suggestions
  year        Int              // e.g. 2026
  createdAt   DateTime         @default(now())
  country     String?
  countryCode String?          @map("country_code")
  region      String?
  regionCode  String?          @map("region_code")
  originLat   Float?           @map("origin_lat")
  originLng   Float?           @map("origin_lng")
  destLat     Float?           @map("dest_lat")
  destLng     Float?           @map("dest_lng")

  // Foreign key to User
  userId      Int              @map("user_id")
  user        User             @relation(fields: [userId], references: [id])

  // One-to-many: a trek has many suggested plants
  // cascade delete handled by Prisma (onDelete: Cascade)
  plants      SuggestedPlant[] @relation("trekPlants")

  // Plants that were originally found in this trek (reverse of foundInTrek)
  plantsFoundHere SuggestedPlant[] @relation("foundInTrek")

  @@map("treks")
}

// A plant suggested by Gemini for a specific trek
// Like @Entity SuggestedPlant in JPA
model SuggestedPlant {
  id             Int       @id @default(autoincrement())
  commonName     String
  scientificName String
  description    String
  rarity         String    @default("common")
  source         String    @default("ai")   // "ai" | "user"
  found          Boolean   @default(false)
  foundAt        DateTime?

  // Trek where this plant was originally found (null if not found yet)
  foundInTrekId  Int?      @map("found_in_trek_id")
  foundInTrek    Trek?     @relation("foundInTrek", fields: [foundInTrekId], references: [id], onDelete: SetNull)

  // One-to-many: a plant has many photos (normalized from old imageUrls column)
  photos         PlantPhoto[]

  // Foreign key to Trek (like @ManyToOne @JoinColumn(name = "trek_id") Trek trek;)
  trekId         Int       @map("trek_id")
  trek           Trek      @relation("trekPlants", fields: [trekId], references: [id], onDelete: Cascade)

  @@map("suggested_plants")
}

// A photo for a plant, fetched from Wikipedia or iNaturalist
model PlantPhoto {
  id       Int    @id @default(autoincrement())
  url      String
  source   String   // "wikipedia" | "inaturalist"
  plantId  Int    @map("plant_id")
  plant    SuggestedPlant @relation(fields: [plantId], references: [id], onDelete: Cascade)

  @@map("plant_photos")
}

// Daily usage counter for Google Maps API calls (free tier = $200/month)
model DailyQuota {
  date  DateTime @id @db.Date
  count Int      @default(0)

  @@map("daily_quota")
}
